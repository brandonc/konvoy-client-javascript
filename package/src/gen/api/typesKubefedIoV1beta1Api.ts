/**
 * Kubernetes
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.16.4
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import localVarRequest = require('request');
import http = require('http');

/* tslint:disable:no-unused-locals */
import { IoKubefedTypesV1beta1FederatedAddonList } from '../model/ioKubefedTypesV1beta1FederatedAddonList';
import { IoKubefedTypesV1beta1FederatedAddonsDeploymentList } from '../model/ioKubefedTypesV1beta1FederatedAddonsDeploymentList';
import { IoKubefedTypesV1beta1FederatedClusterAddonList } from '../model/ioKubefedTypesV1beta1FederatedClusterAddonList';
import { IoKubefedTypesV1beta1FederatedClusterRoleBindingList } from '../model/ioKubefedTypesV1beta1FederatedClusterRoleBindingList';
import { IoKubefedTypesV1beta1FederatedClusterRoleList } from '../model/ioKubefedTypesV1beta1FederatedClusterRoleList';
import { IoKubefedTypesV1beta1FederatedConfigMapList } from '../model/ioKubefedTypesV1beta1FederatedConfigMapList';
import { IoKubefedTypesV1beta1FederatedCustomResourceDefinitionList } from '../model/ioKubefedTypesV1beta1FederatedCustomResourceDefinitionList';
import { IoKubefedTypesV1beta1FederatedDeploymentList } from '../model/ioKubefedTypesV1beta1FederatedDeploymentList';
import { IoKubefedTypesV1beta1FederatedIngressList } from '../model/ioKubefedTypesV1beta1FederatedIngressList';
import { IoKubefedTypesV1beta1FederatedJobList } from '../model/ioKubefedTypesV1beta1FederatedJobList';
import { IoKubefedTypesV1beta1FederatedNamespaceList } from '../model/ioKubefedTypesV1beta1FederatedNamespaceList';
import { IoKubefedTypesV1beta1FederatedReplicaSetList } from '../model/ioKubefedTypesV1beta1FederatedReplicaSetList';
import { IoKubefedTypesV1beta1FederatedRoleBindingList } from '../model/ioKubefedTypesV1beta1FederatedRoleBindingList';
import { IoKubefedTypesV1beta1FederatedRoleList } from '../model/ioKubefedTypesV1beta1FederatedRoleList';
import { IoKubefedTypesV1beta1FederatedSecretList } from '../model/ioKubefedTypesV1beta1FederatedSecretList';
import { IoKubefedTypesV1beta1FederatedServiceAccountList } from '../model/ioKubefedTypesV1beta1FederatedServiceAccountList';
import { IoKubefedTypesV1beta1FederatedServiceList } from '../model/ioKubefedTypesV1beta1FederatedServiceList';
import { V1DeleteOptions } from '../model/v1DeleteOptions';
import { V1Status } from '../model/v1Status';

import { ObjectSerializer, Authentication, VoidAuth } from '../model/models';
import { HttpBasicAuth, ApiKeyAuth, OAuth } from '../model/models';

import { HttpError, RequestFile } from './apis';

let defaultBasePath = 'http://localhost';

// ===============================================
// This file is autogenerated - Please do not edit
// ===============================================

export enum TypesKubefedIoV1beta1ApiApiKeys {
    BearerToken,
}

export class TypesKubefedIoV1beta1Api {
    protected _basePath = defaultBasePath;
    protected defaultHeaders: any = {};
    protected _useQuerystring: boolean = false;

    protected authentications = {
        default: <Authentication>new VoidAuth(),
        BearerToken: new ApiKeyAuth('header', 'authorization'),
    };

    constructor(basePath?: string);
    constructor(basePathOrUsername: string, password?: string, basePath?: string) {
        if (password) {
            if (basePath) {
                this.basePath = basePath;
            }
        } else {
            if (basePathOrUsername) {
                this.basePath = basePathOrUsername;
            }
        }
    }

    set useQuerystring(value: boolean) {
        this._useQuerystring = value;
    }

    set basePath(basePath: string) {
        this._basePath = basePath;
    }

    get basePath() {
        return this._basePath;
    }

    public setDefaultAuthentication(auth: Authentication) {
        this.authentications.default = auth;
    }

    public setApiKey(key: TypesKubefedIoV1beta1ApiApiKeys, value: string) {
        (this.authentications as any)[TypesKubefedIoV1beta1ApiApiKeys[key]].apiKey = value;
    }

    /**
     * create a FederatedClusterAddon
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async createFederatedClusterAddon(
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatedclusteraddons';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling createFederatedClusterAddon.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * create a FederatedClusterRole
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async createFederatedClusterRole(
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatedclusterroles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling createFederatedClusterRole.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * create a FederatedClusterRoleBinding
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async createFederatedClusterRoleBinding(
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatedclusterrolebindings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling createFederatedClusterRoleBinding.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * create a FederatedCustomResourceDefinition
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async createFederatedCustomResourceDefinition(
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath + '/apis/types.kubefed.io/v1beta1/federatedcustomresourcedefinitions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling createFederatedCustomResourceDefinition.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * create a FederatedAddon
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async createNamespacedFederatedAddon(
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedaddons'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling createNamespacedFederatedAddon.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling createNamespacedFederatedAddon.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * create a FederatedAddonsDeployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async createNamespacedFederatedAddonsDeployment(
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedaddonsdeployments'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling createNamespacedFederatedAddonsDeployment.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling createNamespacedFederatedAddonsDeployment.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * create a FederatedConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async createNamespacedFederatedConfigMap(
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedconfigmaps'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling createNamespacedFederatedConfigMap.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling createNamespacedFederatedConfigMap.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * create a FederatedDeployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async createNamespacedFederatedDeployment(
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federateddeployments'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling createNamespacedFederatedDeployment.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling createNamespacedFederatedDeployment.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * create a FederatedIngress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async createNamespacedFederatedIngress(
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedingresses'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling createNamespacedFederatedIngress.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling createNamespacedFederatedIngress.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * create a FederatedJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async createNamespacedFederatedJob(
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedjobs'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling createNamespacedFederatedJob.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling createNamespacedFederatedJob.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * create a FederatedNamespace
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async createNamespacedFederatedNamespace(
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatednamespaces'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling createNamespacedFederatedNamespace.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling createNamespacedFederatedNamespace.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * create a FederatedReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async createNamespacedFederatedReplicaSet(
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedreplicasets'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling createNamespacedFederatedReplicaSet.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling createNamespacedFederatedReplicaSet.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * create a FederatedRole
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async createNamespacedFederatedRole(
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedroles'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling createNamespacedFederatedRole.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling createNamespacedFederatedRole.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * create a FederatedRoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async createNamespacedFederatedRoleBinding(
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedrolebindings'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling createNamespacedFederatedRoleBinding.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling createNamespacedFederatedRoleBinding.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * create a FederatedSecret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async createNamespacedFederatedSecret(
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedsecrets'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling createNamespacedFederatedSecret.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling createNamespacedFederatedSecret.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * create a FederatedService
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async createNamespacedFederatedService(
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedservices'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling createNamespacedFederatedService.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling createNamespacedFederatedService.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * create a FederatedServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async createNamespacedFederatedServiceAccount(
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedserviceaccounts'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling createNamespacedFederatedServiceAccount.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling createNamespacedFederatedServiceAccount.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'POST',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete collection of FederatedClusterAddon
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async deleteCollectionFederatedClusterAddon(
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatedclusteraddons';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete collection of FederatedClusterRole
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async deleteCollectionFederatedClusterRole(
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatedclusterroles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete collection of FederatedClusterRoleBinding
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async deleteCollectionFederatedClusterRoleBinding(
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatedclusterrolebindings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete collection of FederatedCustomResourceDefinition
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async deleteCollectionFederatedCustomResourceDefinition(
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath + '/apis/types.kubefed.io/v1beta1/federatedcustomresourcedefinitions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete collection of FederatedAddon
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async deleteCollectionNamespacedFederatedAddon(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedaddons'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteCollectionNamespacedFederatedAddon.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete collection of FederatedAddonsDeployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async deleteCollectionNamespacedFederatedAddonsDeployment(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedaddonsdeployments'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteCollectionNamespacedFederatedAddonsDeployment.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete collection of FederatedConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async deleteCollectionNamespacedFederatedConfigMap(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedconfigmaps'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteCollectionNamespacedFederatedConfigMap.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete collection of FederatedDeployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async deleteCollectionNamespacedFederatedDeployment(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federateddeployments'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteCollectionNamespacedFederatedDeployment.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete collection of FederatedIngress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async deleteCollectionNamespacedFederatedIngress(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedingresses'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteCollectionNamespacedFederatedIngress.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete collection of FederatedJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async deleteCollectionNamespacedFederatedJob(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedjobs'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteCollectionNamespacedFederatedJob.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete collection of FederatedNamespace
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async deleteCollectionNamespacedFederatedNamespace(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatednamespaces'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteCollectionNamespacedFederatedNamespace.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete collection of FederatedReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async deleteCollectionNamespacedFederatedReplicaSet(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedreplicasets'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteCollectionNamespacedFederatedReplicaSet.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete collection of FederatedRole
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async deleteCollectionNamespacedFederatedRole(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedroles'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteCollectionNamespacedFederatedRole.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete collection of FederatedRoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async deleteCollectionNamespacedFederatedRoleBinding(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedrolebindings'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteCollectionNamespacedFederatedRoleBinding.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete collection of FederatedSecret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async deleteCollectionNamespacedFederatedSecret(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedsecrets'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteCollectionNamespacedFederatedSecret.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete collection of FederatedService
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async deleteCollectionNamespacedFederatedService(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedservices'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteCollectionNamespacedFederatedService.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete collection of FederatedServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async deleteCollectionNamespacedFederatedServiceAccount(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedserviceaccounts'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteCollectionNamespacedFederatedServiceAccount.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete a FederatedClusterAddon
     * @param name name of the FederatedClusterAddon
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param body
     */
    public async deleteFederatedClusterAddon(
        name: string,
        pretty?: string,
        dryRun?: string,
        gracePeriodSeconds?: number,
        orphanDependents?: boolean,
        propagationPolicy?: string,
        body?: V1DeleteOptions,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusteraddons/{name}'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling deleteFederatedClusterAddon.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (gracePeriodSeconds !== undefined) {
            localVarQueryParameters['gracePeriodSeconds'] = ObjectSerializer.serialize(
                gracePeriodSeconds,
                'number',
            );
        }

        if (orphanDependents !== undefined) {
            localVarQueryParameters['orphanDependents'] = ObjectSerializer.serialize(
                orphanDependents,
                'boolean',
            );
        }

        if (propagationPolicy !== undefined) {
            localVarQueryParameters['propagationPolicy'] = ObjectSerializer.serialize(
                propagationPolicy,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'V1DeleteOptions'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete a FederatedClusterRole
     * @param name name of the FederatedClusterRole
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param body
     */
    public async deleteFederatedClusterRole(
        name: string,
        pretty?: string,
        dryRun?: string,
        gracePeriodSeconds?: number,
        orphanDependents?: boolean,
        propagationPolicy?: string,
        body?: V1DeleteOptions,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusterroles/{name}'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling deleteFederatedClusterRole.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (gracePeriodSeconds !== undefined) {
            localVarQueryParameters['gracePeriodSeconds'] = ObjectSerializer.serialize(
                gracePeriodSeconds,
                'number',
            );
        }

        if (orphanDependents !== undefined) {
            localVarQueryParameters['orphanDependents'] = ObjectSerializer.serialize(
                orphanDependents,
                'boolean',
            );
        }

        if (propagationPolicy !== undefined) {
            localVarQueryParameters['propagationPolicy'] = ObjectSerializer.serialize(
                propagationPolicy,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'V1DeleteOptions'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete a FederatedClusterRoleBinding
     * @param name name of the FederatedClusterRoleBinding
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param body
     */
    public async deleteFederatedClusterRoleBinding(
        name: string,
        pretty?: string,
        dryRun?: string,
        gracePeriodSeconds?: number,
        orphanDependents?: boolean,
        propagationPolicy?: string,
        body?: V1DeleteOptions,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusterrolebindings/{name}'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling deleteFederatedClusterRoleBinding.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (gracePeriodSeconds !== undefined) {
            localVarQueryParameters['gracePeriodSeconds'] = ObjectSerializer.serialize(
                gracePeriodSeconds,
                'number',
            );
        }

        if (orphanDependents !== undefined) {
            localVarQueryParameters['orphanDependents'] = ObjectSerializer.serialize(
                orphanDependents,
                'boolean',
            );
        }

        if (propagationPolicy !== undefined) {
            localVarQueryParameters['propagationPolicy'] = ObjectSerializer.serialize(
                propagationPolicy,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'V1DeleteOptions'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete a FederatedCustomResourceDefinition
     * @param name name of the FederatedCustomResourceDefinition
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param body
     */
    public async deleteFederatedCustomResourceDefinition(
        name: string,
        pretty?: string,
        dryRun?: string,
        gracePeriodSeconds?: number,
        orphanDependents?: boolean,
        propagationPolicy?: string,
        body?: V1DeleteOptions,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedcustomresourcedefinitions/{name}'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling deleteFederatedCustomResourceDefinition.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (gracePeriodSeconds !== undefined) {
            localVarQueryParameters['gracePeriodSeconds'] = ObjectSerializer.serialize(
                gracePeriodSeconds,
                'number',
            );
        }

        if (orphanDependents !== undefined) {
            localVarQueryParameters['orphanDependents'] = ObjectSerializer.serialize(
                orphanDependents,
                'boolean',
            );
        }

        if (propagationPolicy !== undefined) {
            localVarQueryParameters['propagationPolicy'] = ObjectSerializer.serialize(
                propagationPolicy,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'V1DeleteOptions'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete a FederatedAddon
     * @param name name of the FederatedAddon
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param body
     */
    public async deleteNamespacedFederatedAddon(
        name: string,
        namespace: string,
        pretty?: string,
        dryRun?: string,
        gracePeriodSeconds?: number,
        orphanDependents?: boolean,
        propagationPolicy?: string,
        body?: V1DeleteOptions,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedaddons/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling deleteNamespacedFederatedAddon.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteNamespacedFederatedAddon.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (gracePeriodSeconds !== undefined) {
            localVarQueryParameters['gracePeriodSeconds'] = ObjectSerializer.serialize(
                gracePeriodSeconds,
                'number',
            );
        }

        if (orphanDependents !== undefined) {
            localVarQueryParameters['orphanDependents'] = ObjectSerializer.serialize(
                orphanDependents,
                'boolean',
            );
        }

        if (propagationPolicy !== undefined) {
            localVarQueryParameters['propagationPolicy'] = ObjectSerializer.serialize(
                propagationPolicy,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'V1DeleteOptions'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete a FederatedAddonsDeployment
     * @param name name of the FederatedAddonsDeployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param body
     */
    public async deleteNamespacedFederatedAddonsDeployment(
        name: string,
        namespace: string,
        pretty?: string,
        dryRun?: string,
        gracePeriodSeconds?: number,
        orphanDependents?: boolean,
        propagationPolicy?: string,
        body?: V1DeleteOptions,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedaddonsdeployments/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling deleteNamespacedFederatedAddonsDeployment.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteNamespacedFederatedAddonsDeployment.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (gracePeriodSeconds !== undefined) {
            localVarQueryParameters['gracePeriodSeconds'] = ObjectSerializer.serialize(
                gracePeriodSeconds,
                'number',
            );
        }

        if (orphanDependents !== undefined) {
            localVarQueryParameters['orphanDependents'] = ObjectSerializer.serialize(
                orphanDependents,
                'boolean',
            );
        }

        if (propagationPolicy !== undefined) {
            localVarQueryParameters['propagationPolicy'] = ObjectSerializer.serialize(
                propagationPolicy,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'V1DeleteOptions'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete a FederatedConfigMap
     * @param name name of the FederatedConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param body
     */
    public async deleteNamespacedFederatedConfigMap(
        name: string,
        namespace: string,
        pretty?: string,
        dryRun?: string,
        gracePeriodSeconds?: number,
        orphanDependents?: boolean,
        propagationPolicy?: string,
        body?: V1DeleteOptions,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedconfigmaps/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling deleteNamespacedFederatedConfigMap.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteNamespacedFederatedConfigMap.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (gracePeriodSeconds !== undefined) {
            localVarQueryParameters['gracePeriodSeconds'] = ObjectSerializer.serialize(
                gracePeriodSeconds,
                'number',
            );
        }

        if (orphanDependents !== undefined) {
            localVarQueryParameters['orphanDependents'] = ObjectSerializer.serialize(
                orphanDependents,
                'boolean',
            );
        }

        if (propagationPolicy !== undefined) {
            localVarQueryParameters['propagationPolicy'] = ObjectSerializer.serialize(
                propagationPolicy,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'V1DeleteOptions'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete a FederatedDeployment
     * @param name name of the FederatedDeployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param body
     */
    public async deleteNamespacedFederatedDeployment(
        name: string,
        namespace: string,
        pretty?: string,
        dryRun?: string,
        gracePeriodSeconds?: number,
        orphanDependents?: boolean,
        propagationPolicy?: string,
        body?: V1DeleteOptions,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federateddeployments/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling deleteNamespacedFederatedDeployment.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteNamespacedFederatedDeployment.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (gracePeriodSeconds !== undefined) {
            localVarQueryParameters['gracePeriodSeconds'] = ObjectSerializer.serialize(
                gracePeriodSeconds,
                'number',
            );
        }

        if (orphanDependents !== undefined) {
            localVarQueryParameters['orphanDependents'] = ObjectSerializer.serialize(
                orphanDependents,
                'boolean',
            );
        }

        if (propagationPolicy !== undefined) {
            localVarQueryParameters['propagationPolicy'] = ObjectSerializer.serialize(
                propagationPolicy,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'V1DeleteOptions'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete a FederatedIngress
     * @param name name of the FederatedIngress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param body
     */
    public async deleteNamespacedFederatedIngress(
        name: string,
        namespace: string,
        pretty?: string,
        dryRun?: string,
        gracePeriodSeconds?: number,
        orphanDependents?: boolean,
        propagationPolicy?: string,
        body?: V1DeleteOptions,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedingresses/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling deleteNamespacedFederatedIngress.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteNamespacedFederatedIngress.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (gracePeriodSeconds !== undefined) {
            localVarQueryParameters['gracePeriodSeconds'] = ObjectSerializer.serialize(
                gracePeriodSeconds,
                'number',
            );
        }

        if (orphanDependents !== undefined) {
            localVarQueryParameters['orphanDependents'] = ObjectSerializer.serialize(
                orphanDependents,
                'boolean',
            );
        }

        if (propagationPolicy !== undefined) {
            localVarQueryParameters['propagationPolicy'] = ObjectSerializer.serialize(
                propagationPolicy,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'V1DeleteOptions'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete a FederatedJob
     * @param name name of the FederatedJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param body
     */
    public async deleteNamespacedFederatedJob(
        name: string,
        namespace: string,
        pretty?: string,
        dryRun?: string,
        gracePeriodSeconds?: number,
        orphanDependents?: boolean,
        propagationPolicy?: string,
        body?: V1DeleteOptions,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedjobs/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling deleteNamespacedFederatedJob.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteNamespacedFederatedJob.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (gracePeriodSeconds !== undefined) {
            localVarQueryParameters['gracePeriodSeconds'] = ObjectSerializer.serialize(
                gracePeriodSeconds,
                'number',
            );
        }

        if (orphanDependents !== undefined) {
            localVarQueryParameters['orphanDependents'] = ObjectSerializer.serialize(
                orphanDependents,
                'boolean',
            );
        }

        if (propagationPolicy !== undefined) {
            localVarQueryParameters['propagationPolicy'] = ObjectSerializer.serialize(
                propagationPolicy,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'V1DeleteOptions'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete a FederatedNamespace
     * @param name name of the FederatedNamespace
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param body
     */
    public async deleteNamespacedFederatedNamespace(
        name: string,
        namespace: string,
        pretty?: string,
        dryRun?: string,
        gracePeriodSeconds?: number,
        orphanDependents?: boolean,
        propagationPolicy?: string,
        body?: V1DeleteOptions,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatednamespaces/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling deleteNamespacedFederatedNamespace.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteNamespacedFederatedNamespace.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (gracePeriodSeconds !== undefined) {
            localVarQueryParameters['gracePeriodSeconds'] = ObjectSerializer.serialize(
                gracePeriodSeconds,
                'number',
            );
        }

        if (orphanDependents !== undefined) {
            localVarQueryParameters['orphanDependents'] = ObjectSerializer.serialize(
                orphanDependents,
                'boolean',
            );
        }

        if (propagationPolicy !== undefined) {
            localVarQueryParameters['propagationPolicy'] = ObjectSerializer.serialize(
                propagationPolicy,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'V1DeleteOptions'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete a FederatedReplicaSet
     * @param name name of the FederatedReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param body
     */
    public async deleteNamespacedFederatedReplicaSet(
        name: string,
        namespace: string,
        pretty?: string,
        dryRun?: string,
        gracePeriodSeconds?: number,
        orphanDependents?: boolean,
        propagationPolicy?: string,
        body?: V1DeleteOptions,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedreplicasets/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling deleteNamespacedFederatedReplicaSet.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteNamespacedFederatedReplicaSet.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (gracePeriodSeconds !== undefined) {
            localVarQueryParameters['gracePeriodSeconds'] = ObjectSerializer.serialize(
                gracePeriodSeconds,
                'number',
            );
        }

        if (orphanDependents !== undefined) {
            localVarQueryParameters['orphanDependents'] = ObjectSerializer.serialize(
                orphanDependents,
                'boolean',
            );
        }

        if (propagationPolicy !== undefined) {
            localVarQueryParameters['propagationPolicy'] = ObjectSerializer.serialize(
                propagationPolicy,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'V1DeleteOptions'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete a FederatedRole
     * @param name name of the FederatedRole
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param body
     */
    public async deleteNamespacedFederatedRole(
        name: string,
        namespace: string,
        pretty?: string,
        dryRun?: string,
        gracePeriodSeconds?: number,
        orphanDependents?: boolean,
        propagationPolicy?: string,
        body?: V1DeleteOptions,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedroles/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling deleteNamespacedFederatedRole.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteNamespacedFederatedRole.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (gracePeriodSeconds !== undefined) {
            localVarQueryParameters['gracePeriodSeconds'] = ObjectSerializer.serialize(
                gracePeriodSeconds,
                'number',
            );
        }

        if (orphanDependents !== undefined) {
            localVarQueryParameters['orphanDependents'] = ObjectSerializer.serialize(
                orphanDependents,
                'boolean',
            );
        }

        if (propagationPolicy !== undefined) {
            localVarQueryParameters['propagationPolicy'] = ObjectSerializer.serialize(
                propagationPolicy,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'V1DeleteOptions'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete a FederatedRoleBinding
     * @param name name of the FederatedRoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param body
     */
    public async deleteNamespacedFederatedRoleBinding(
        name: string,
        namespace: string,
        pretty?: string,
        dryRun?: string,
        gracePeriodSeconds?: number,
        orphanDependents?: boolean,
        propagationPolicy?: string,
        body?: V1DeleteOptions,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedrolebindings/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling deleteNamespacedFederatedRoleBinding.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteNamespacedFederatedRoleBinding.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (gracePeriodSeconds !== undefined) {
            localVarQueryParameters['gracePeriodSeconds'] = ObjectSerializer.serialize(
                gracePeriodSeconds,
                'number',
            );
        }

        if (orphanDependents !== undefined) {
            localVarQueryParameters['orphanDependents'] = ObjectSerializer.serialize(
                orphanDependents,
                'boolean',
            );
        }

        if (propagationPolicy !== undefined) {
            localVarQueryParameters['propagationPolicy'] = ObjectSerializer.serialize(
                propagationPolicy,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'V1DeleteOptions'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete a FederatedSecret
     * @param name name of the FederatedSecret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param body
     */
    public async deleteNamespacedFederatedSecret(
        name: string,
        namespace: string,
        pretty?: string,
        dryRun?: string,
        gracePeriodSeconds?: number,
        orphanDependents?: boolean,
        propagationPolicy?: string,
        body?: V1DeleteOptions,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedsecrets/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling deleteNamespacedFederatedSecret.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteNamespacedFederatedSecret.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (gracePeriodSeconds !== undefined) {
            localVarQueryParameters['gracePeriodSeconds'] = ObjectSerializer.serialize(
                gracePeriodSeconds,
                'number',
            );
        }

        if (orphanDependents !== undefined) {
            localVarQueryParameters['orphanDependents'] = ObjectSerializer.serialize(
                orphanDependents,
                'boolean',
            );
        }

        if (propagationPolicy !== undefined) {
            localVarQueryParameters['propagationPolicy'] = ObjectSerializer.serialize(
                propagationPolicy,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'V1DeleteOptions'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete a FederatedService
     * @param name name of the FederatedService
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param body
     */
    public async deleteNamespacedFederatedService(
        name: string,
        namespace: string,
        pretty?: string,
        dryRun?: string,
        gracePeriodSeconds?: number,
        orphanDependents?: boolean,
        propagationPolicy?: string,
        body?: V1DeleteOptions,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedservices/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling deleteNamespacedFederatedService.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteNamespacedFederatedService.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (gracePeriodSeconds !== undefined) {
            localVarQueryParameters['gracePeriodSeconds'] = ObjectSerializer.serialize(
                gracePeriodSeconds,
                'number',
            );
        }

        if (orphanDependents !== undefined) {
            localVarQueryParameters['orphanDependents'] = ObjectSerializer.serialize(
                orphanDependents,
                'boolean',
            );
        }

        if (propagationPolicy !== undefined) {
            localVarQueryParameters['propagationPolicy'] = ObjectSerializer.serialize(
                propagationPolicy,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'V1DeleteOptions'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * delete a FederatedServiceAccount
     * @param name name of the FederatedServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param gracePeriodSeconds The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
     * @param orphanDependents Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the \&quot;orphan\&quot; finalizer will be added to/removed from the object\&#39;s finalizers list. Either this field or PropagationPolicy may be set, but not both.
     * @param propagationPolicy Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy. Acceptable values are: \&#39;Orphan\&#39; - orphan the dependents; \&#39;Background\&#39; - allow the garbage collector to delete the dependents in the background; \&#39;Foreground\&#39; - a cascading policy that deletes all dependents in the foreground.
     * @param body
     */
    public async deleteNamespacedFederatedServiceAccount(
        name: string,
        namespace: string,
        pretty?: string,
        dryRun?: string,
        gracePeriodSeconds?: number,
        orphanDependents?: boolean,
        propagationPolicy?: string,
        body?: V1DeleteOptions,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: V1Status }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedserviceaccounts/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling deleteNamespacedFederatedServiceAccount.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling deleteNamespacedFederatedServiceAccount.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (gracePeriodSeconds !== undefined) {
            localVarQueryParameters['gracePeriodSeconds'] = ObjectSerializer.serialize(
                gracePeriodSeconds,
                'number',
            );
        }

        if (orphanDependents !== undefined) {
            localVarQueryParameters['orphanDependents'] = ObjectSerializer.serialize(
                orphanDependents,
                'boolean',
            );
        }

        if (propagationPolicy !== undefined) {
            localVarQueryParameters['propagationPolicy'] = ObjectSerializer.serialize(
                propagationPolicy,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'DELETE',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'V1DeleteOptions'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: V1Status }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'V1Status');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedAddon
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listFederatedAddonForAllNamespaces(
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        pretty?: string,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedAddonList }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatedaddons';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedAddonList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'IoKubefedTypesV1beta1FederatedAddonList');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedAddonsDeployment
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listFederatedAddonsDeploymentForAllNamespaces(
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        pretty?: string,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedAddonsDeploymentList }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatedaddonsdeployments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedAddonsDeploymentList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedAddonsDeploymentList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedClusterAddon
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listFederatedClusterAddon(
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedClusterAddonList }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatedclusteraddons';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedClusterAddonList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedClusterAddonList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedClusterRole
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listFederatedClusterRole(
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedClusterRoleList }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatedclusterroles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedClusterRoleList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedClusterRoleList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedClusterRoleBinding
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listFederatedClusterRoleBinding(
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{
        response: http.IncomingMessage;
        body: IoKubefedTypesV1beta1FederatedClusterRoleBindingList;
    }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatedclusterrolebindings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedClusterRoleBindingList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedClusterRoleBindingList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedConfigMap
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listFederatedConfigMapForAllNamespaces(
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        pretty?: string,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedConfigMapList }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatedconfigmaps';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedConfigMapList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedConfigMapList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedCustomResourceDefinition
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listFederatedCustomResourceDefinition(
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{
        response: http.IncomingMessage;
        body: IoKubefedTypesV1beta1FederatedCustomResourceDefinitionList;
    }> {
        const localVarPath =
            this.basePath + '/apis/types.kubefed.io/v1beta1/federatedcustomresourcedefinitions';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedCustomResourceDefinitionList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedCustomResourceDefinitionList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedDeployment
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listFederatedDeploymentForAllNamespaces(
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        pretty?: string,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedDeploymentList }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federateddeployments';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedDeploymentList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedDeploymentList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedIngress
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listFederatedIngressForAllNamespaces(
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        pretty?: string,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedIngressList }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatedingresses';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedIngressList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedIngressList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedJob
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listFederatedJobForAllNamespaces(
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        pretty?: string,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedJobList }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatedjobs';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedJobList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'IoKubefedTypesV1beta1FederatedJobList');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedNamespace
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listFederatedNamespaceForAllNamespaces(
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        pretty?: string,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedNamespaceList }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatednamespaces';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedNamespaceList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedNamespaceList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedReplicaSet
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listFederatedReplicaSetForAllNamespaces(
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        pretty?: string,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedReplicaSetList }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatedreplicasets';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedReplicaSetList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedReplicaSetList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedRoleBinding
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listFederatedRoleBindingForAllNamespaces(
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        pretty?: string,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedRoleBindingList }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatedrolebindings';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedRoleBindingList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedRoleBindingList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedRole
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listFederatedRoleForAllNamespaces(
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        pretty?: string,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedRoleList }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatedroles';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedRoleList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'IoKubefedTypesV1beta1FederatedRoleList');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedSecret
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listFederatedSecretForAllNamespaces(
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        pretty?: string,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedSecretList }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatedsecrets';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedSecretList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'IoKubefedTypesV1beta1FederatedSecretList');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedServiceAccount
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listFederatedServiceAccountForAllNamespaces(
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        pretty?: string,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedServiceAccountList }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatedserviceaccounts';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedServiceAccountList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedServiceAccountList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedService
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listFederatedServiceForAllNamespaces(
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        pretty?: string,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedServiceList }> {
        const localVarPath = this.basePath + '/apis/types.kubefed.io/v1beta1/federatedservices';
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedServiceList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedServiceList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedAddon
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listNamespacedFederatedAddon(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedAddonList }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedaddons'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling listNamespacedFederatedAddon.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedAddonList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'IoKubefedTypesV1beta1FederatedAddonList');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedAddonsDeployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listNamespacedFederatedAddonsDeployment(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedAddonsDeploymentList }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedaddonsdeployments'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling listNamespacedFederatedAddonsDeployment.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedAddonsDeploymentList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedAddonsDeploymentList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listNamespacedFederatedConfigMap(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedConfigMapList }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedconfigmaps'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling listNamespacedFederatedConfigMap.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedConfigMapList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedConfigMapList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedDeployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listNamespacedFederatedDeployment(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedDeploymentList }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federateddeployments'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling listNamespacedFederatedDeployment.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedDeploymentList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedDeploymentList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedIngress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listNamespacedFederatedIngress(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedIngressList }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedingresses'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling listNamespacedFederatedIngress.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedIngressList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedIngressList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listNamespacedFederatedJob(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedJobList }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedjobs'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling listNamespacedFederatedJob.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedJobList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'IoKubefedTypesV1beta1FederatedJobList');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedNamespace
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listNamespacedFederatedNamespace(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedNamespaceList }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatednamespaces'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling listNamespacedFederatedNamespace.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedNamespaceList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedNamespaceList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listNamespacedFederatedReplicaSet(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedReplicaSetList }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedreplicasets'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling listNamespacedFederatedReplicaSet.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedReplicaSetList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedReplicaSetList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedRole
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listNamespacedFederatedRole(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedRoleList }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedroles'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling listNamespacedFederatedRole.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedRoleList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'IoKubefedTypesV1beta1FederatedRoleList');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedRoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listNamespacedFederatedRoleBinding(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedRoleBindingList }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedrolebindings'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling listNamespacedFederatedRoleBinding.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedRoleBindingList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedRoleBindingList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedSecret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listNamespacedFederatedSecret(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedSecretList }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedsecrets'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling listNamespacedFederatedSecret.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedSecretList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'IoKubefedTypesV1beta1FederatedSecretList');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedService
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listNamespacedFederatedService(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedServiceList }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedservices'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling listNamespacedFederatedService.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedServiceList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedServiceList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * list objects of kind FederatedServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param allowWatchBookmarks allowWatchBookmarks requests watch events with type \&quot;BOOKMARK\&quot;. Servers that do not implement bookmarks may ignore this flag and bookmarks are sent at the server\&#39;s discretion. Clients should not assume bookmarks are returned at any specific interval, nor may they assume the server will send any BOOKMARK event during a session. If this is not a watch, this field is ignored. If the feature gate WatchBookmarks is not enabled in apiserver, this field is ignored.  This field is beta.
     * @param _continue The continue option should be set when retrieving more results from the server. Since this value is server defined, clients may only use the continue value from a previous query result with identical query parameters (except for the value of continue) and the server may reject a continue value it does not recognize. If the specified continue value is no longer valid whether due to expiration (generally five to fifteen minutes) or a configuration change on the server, the server will respond with a 410 ResourceExpired error together with a continue token. If the client needs a consistent list, it must restart their list without the continue field. Otherwise, the client may send another list request with the token received with the 410 error, the server will respond with a list starting from the next key, but from the latest snapshot, which is inconsistent from the previous list results - objects that are created, modified, or deleted after the first list request will be included in the response, as long as their keys are after the \&quot;next key\&quot;.  This field is not supported when watch is true. Clients may start a watch from the last resourceVersion value returned by the server and not miss any modifications.
     * @param fieldSelector A selector to restrict the list of returned objects by their fields. Defaults to everything.
     * @param labelSelector A selector to restrict the list of returned objects by their labels. Defaults to everything.
     * @param limit limit is a maximum number of responses to return for a list call. If more items exist, the server will set the &#x60;continue&#x60; field on the list metadata to a value that can be used with the same initial query to retrieve the next set of results. Setting a limit may return fewer than the requested amount of items (up to zero items) in the event all requested objects are filtered out and clients should only use the presence of the continue field to determine whether more results are available. Servers may choose not to support the limit argument and will return all of the available results. If limit is specified and the continue field is empty, clients may assume that no more results are available. This field is not supported if watch is true.  The server guarantees that the objects returned when using continue will be identical to issuing a single list call without a limit - that is, no objects created, modified, or deleted after the first request is issued will be included in any subsequent continued requests. This is sometimes referred to as a consistent snapshot, and ensures that a client that is using limit to receive smaller chunks of a very large result can ensure they see all possible objects. If objects are updated during a chunked list the version of the object that was present at the time the first list result was calculated is returned.
     * @param resourceVersion When specified with a watch call, shows changes that occur after that particular version of a resource. Defaults to changes from the beginning of history. When specified for list: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     * @param timeoutSeconds Timeout for the list/watch call. This limits the duration of the call, regardless of any activity or inactivity.
     * @param watch Watch for changes to the described resources and return them as a stream of add, update, and remove notifications. Specify resourceVersion.
     */
    public async listNamespacedFederatedServiceAccount(
        namespace: string,
        pretty?: string,
        allowWatchBookmarks?: boolean,
        _continue?: string,
        fieldSelector?: string,
        labelSelector?: string,
        limit?: number,
        resourceVersion?: string,
        timeoutSeconds?: number,
        watch?: boolean,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: IoKubefedTypesV1beta1FederatedServiceAccountList }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedserviceaccounts'.replace(
                '{' + 'namespace' + '}',
                encodeURIComponent(String(namespace)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling listNamespacedFederatedServiceAccount.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (allowWatchBookmarks !== undefined) {
            localVarQueryParameters['allowWatchBookmarks'] = ObjectSerializer.serialize(
                allowWatchBookmarks,
                'boolean',
            );
        }

        if (_continue !== undefined) {
            localVarQueryParameters['continue'] = ObjectSerializer.serialize(_continue, 'string');
        }

        if (fieldSelector !== undefined) {
            localVarQueryParameters['fieldSelector'] = ObjectSerializer.serialize(fieldSelector, 'string');
        }

        if (labelSelector !== undefined) {
            localVarQueryParameters['labelSelector'] = ObjectSerializer.serialize(labelSelector, 'string');
        }

        if (limit !== undefined) {
            localVarQueryParameters['limit'] = ObjectSerializer.serialize(limit, 'number');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        if (timeoutSeconds !== undefined) {
            localVarQueryParameters['timeoutSeconds'] = ObjectSerializer.serialize(timeoutSeconds, 'number');
        }

        if (watch !== undefined) {
            localVarQueryParameters['watch'] = ObjectSerializer.serialize(watch, 'boolean');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{
                response: http.IncomingMessage;
                body: IoKubefedTypesV1beta1FederatedServiceAccountList;
            }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(
                            body,
                            'IoKubefedTypesV1beta1FederatedServiceAccountList',
                        );
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update the specified FederatedClusterAddon
     * @param name name of the FederatedClusterAddon
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchFederatedClusterAddon(
        name: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusteraddons/{name}'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchFederatedClusterAddon.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchFederatedClusterAddon.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update status of the specified FederatedClusterAddon
     * @param name name of the FederatedClusterAddon
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchFederatedClusterAddonStatus(
        name: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusteraddons/{name}/status'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchFederatedClusterAddonStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchFederatedClusterAddonStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update the specified FederatedClusterRole
     * @param name name of the FederatedClusterRole
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchFederatedClusterRole(
        name: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusterroles/{name}'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchFederatedClusterRole.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchFederatedClusterRole.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update the specified FederatedClusterRoleBinding
     * @param name name of the FederatedClusterRoleBinding
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchFederatedClusterRoleBinding(
        name: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusterrolebindings/{name}'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchFederatedClusterRoleBinding.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchFederatedClusterRoleBinding.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update status of the specified FederatedClusterRoleBinding
     * @param name name of the FederatedClusterRoleBinding
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchFederatedClusterRoleBindingStatus(
        name: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusterrolebindings/{name}/status'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchFederatedClusterRoleBindingStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchFederatedClusterRoleBindingStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update status of the specified FederatedClusterRole
     * @param name name of the FederatedClusterRole
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchFederatedClusterRoleStatus(
        name: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusterroles/{name}/status'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchFederatedClusterRoleStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchFederatedClusterRoleStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update the specified FederatedCustomResourceDefinition
     * @param name name of the FederatedCustomResourceDefinition
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchFederatedCustomResourceDefinition(
        name: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedcustomresourcedefinitions/{name}'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchFederatedCustomResourceDefinition.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchFederatedCustomResourceDefinition.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update status of the specified FederatedCustomResourceDefinition
     * @param name name of the FederatedCustomResourceDefinition
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchFederatedCustomResourceDefinitionStatus(
        name: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedcustomresourcedefinitions/{name}/status'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchFederatedCustomResourceDefinitionStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchFederatedCustomResourceDefinitionStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update the specified FederatedAddon
     * @param name name of the FederatedAddon
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedAddon(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedaddons/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedAddon.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedAddon.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedAddon.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update status of the specified FederatedAddon
     * @param name name of the FederatedAddon
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedAddonStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedaddons/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedAddonStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedAddonStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedAddonStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update the specified FederatedAddonsDeployment
     * @param name name of the FederatedAddonsDeployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedAddonsDeployment(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedaddonsdeployments/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedAddonsDeployment.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedAddonsDeployment.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedAddonsDeployment.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update status of the specified FederatedAddonsDeployment
     * @param name name of the FederatedAddonsDeployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedAddonsDeploymentStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedaddonsdeployments/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedAddonsDeploymentStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedAddonsDeploymentStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedAddonsDeploymentStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update the specified FederatedConfigMap
     * @param name name of the FederatedConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedConfigMap(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedconfigmaps/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedConfigMap.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedConfigMap.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedConfigMap.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update status of the specified FederatedConfigMap
     * @param name name of the FederatedConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedConfigMapStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedconfigmaps/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedConfigMapStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedConfigMapStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedConfigMapStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update the specified FederatedDeployment
     * @param name name of the FederatedDeployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedDeployment(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federateddeployments/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedDeployment.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedDeployment.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedDeployment.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update status of the specified FederatedDeployment
     * @param name name of the FederatedDeployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedDeploymentStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federateddeployments/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedDeploymentStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedDeploymentStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedDeploymentStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update the specified FederatedIngress
     * @param name name of the FederatedIngress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedIngress(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedingresses/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedIngress.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedIngress.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedIngress.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update status of the specified FederatedIngress
     * @param name name of the FederatedIngress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedIngressStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedingresses/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedIngressStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedIngressStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedIngressStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update the specified FederatedJob
     * @param name name of the FederatedJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedJob(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedjobs/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedJob.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedJob.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedJob.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update status of the specified FederatedJob
     * @param name name of the FederatedJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedJobStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedjobs/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedJobStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedJobStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedJobStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update the specified FederatedNamespace
     * @param name name of the FederatedNamespace
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedNamespace(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatednamespaces/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedNamespace.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedNamespace.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedNamespace.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update status of the specified FederatedNamespace
     * @param name name of the FederatedNamespace
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedNamespaceStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatednamespaces/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedNamespaceStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedNamespaceStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedNamespaceStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update the specified FederatedReplicaSet
     * @param name name of the FederatedReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedReplicaSet(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedreplicasets/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedReplicaSet.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedReplicaSet.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedReplicaSet.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update status of the specified FederatedReplicaSet
     * @param name name of the FederatedReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedReplicaSetStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedreplicasets/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedReplicaSetStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedReplicaSetStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedReplicaSetStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update the specified FederatedRole
     * @param name name of the FederatedRole
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedRole(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedroles/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedRole.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedRole.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedRole.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update the specified FederatedRoleBinding
     * @param name name of the FederatedRoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedRoleBinding(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedrolebindings/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedRoleBinding.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedRoleBinding.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedRoleBinding.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update status of the specified FederatedRoleBinding
     * @param name name of the FederatedRoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedRoleBindingStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedrolebindings/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedRoleBindingStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedRoleBindingStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedRoleBindingStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update status of the specified FederatedRole
     * @param name name of the FederatedRole
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedRoleStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedroles/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedRoleStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedRoleStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedRoleStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update the specified FederatedSecret
     * @param name name of the FederatedSecret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedSecret(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedsecrets/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedSecret.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedSecret.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedSecret.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update status of the specified FederatedSecret
     * @param name name of the FederatedSecret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedSecretStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedsecrets/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedSecretStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedSecretStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedSecretStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update the specified FederatedService
     * @param name name of the FederatedService
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedService(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedservices/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedService.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedService.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedService.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update the specified FederatedServiceAccount
     * @param name name of the FederatedServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedServiceAccount(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedserviceaccounts/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedServiceAccount.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedServiceAccount.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedServiceAccount.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update status of the specified FederatedServiceAccount
     * @param name name of the FederatedServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedServiceAccountStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedserviceaccounts/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedServiceAccountStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedServiceAccountStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedServiceAccountStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * partially update status of the specified FederatedService
     * @param name name of the FederatedService
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async patchNamespacedFederatedServiceStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedservices/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling patchNamespacedFederatedServiceStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling patchNamespacedFederatedServiceStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling patchNamespacedFederatedServiceStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PATCH',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read the specified FederatedClusterAddon
     * @param name name of the FederatedClusterAddon
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readFederatedClusterAddon(
        name: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusteraddons/{name}'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readFederatedClusterAddon.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read status of the specified FederatedClusterAddon
     * @param name name of the FederatedClusterAddon
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readFederatedClusterAddonStatus(
        name: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusteraddons/{name}/status'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readFederatedClusterAddonStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read the specified FederatedClusterRole
     * @param name name of the FederatedClusterRole
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readFederatedClusterRole(
        name: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusterroles/{name}'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readFederatedClusterRole.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read the specified FederatedClusterRoleBinding
     * @param name name of the FederatedClusterRoleBinding
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readFederatedClusterRoleBinding(
        name: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusterrolebindings/{name}'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readFederatedClusterRoleBinding.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read status of the specified FederatedClusterRoleBinding
     * @param name name of the FederatedClusterRoleBinding
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readFederatedClusterRoleBindingStatus(
        name: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusterrolebindings/{name}/status'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readFederatedClusterRoleBindingStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read status of the specified FederatedClusterRole
     * @param name name of the FederatedClusterRole
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readFederatedClusterRoleStatus(
        name: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusterroles/{name}/status'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readFederatedClusterRoleStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read the specified FederatedCustomResourceDefinition
     * @param name name of the FederatedCustomResourceDefinition
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readFederatedCustomResourceDefinition(
        name: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedcustomresourcedefinitions/{name}'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readFederatedCustomResourceDefinition.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read status of the specified FederatedCustomResourceDefinition
     * @param name name of the FederatedCustomResourceDefinition
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readFederatedCustomResourceDefinitionStatus(
        name: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedcustomresourcedefinitions/{name}/status'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readFederatedCustomResourceDefinitionStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read the specified FederatedAddon
     * @param name name of the FederatedAddon
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedAddon(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedaddons/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedAddon.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedAddon.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read status of the specified FederatedAddon
     * @param name name of the FederatedAddon
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedAddonStatus(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedaddons/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedAddonStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedAddonStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read the specified FederatedAddonsDeployment
     * @param name name of the FederatedAddonsDeployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedAddonsDeployment(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedaddonsdeployments/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedAddonsDeployment.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedAddonsDeployment.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read status of the specified FederatedAddonsDeployment
     * @param name name of the FederatedAddonsDeployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedAddonsDeploymentStatus(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedaddonsdeployments/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedAddonsDeploymentStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedAddonsDeploymentStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read the specified FederatedConfigMap
     * @param name name of the FederatedConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedConfigMap(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedconfigmaps/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedConfigMap.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedConfigMap.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read status of the specified FederatedConfigMap
     * @param name name of the FederatedConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedConfigMapStatus(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedconfigmaps/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedConfigMapStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedConfigMapStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read the specified FederatedDeployment
     * @param name name of the FederatedDeployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedDeployment(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federateddeployments/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedDeployment.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedDeployment.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read status of the specified FederatedDeployment
     * @param name name of the FederatedDeployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedDeploymentStatus(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federateddeployments/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedDeploymentStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedDeploymentStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read the specified FederatedIngress
     * @param name name of the FederatedIngress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedIngress(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedingresses/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedIngress.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedIngress.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read status of the specified FederatedIngress
     * @param name name of the FederatedIngress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedIngressStatus(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedingresses/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedIngressStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedIngressStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read the specified FederatedJob
     * @param name name of the FederatedJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedJob(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedjobs/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedJob.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedJob.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read status of the specified FederatedJob
     * @param name name of the FederatedJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedJobStatus(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedjobs/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedJobStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedJobStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read the specified FederatedNamespace
     * @param name name of the FederatedNamespace
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedNamespace(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatednamespaces/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedNamespace.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedNamespace.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read status of the specified FederatedNamespace
     * @param name name of the FederatedNamespace
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedNamespaceStatus(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatednamespaces/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedNamespaceStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedNamespaceStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read the specified FederatedReplicaSet
     * @param name name of the FederatedReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedReplicaSet(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedreplicasets/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedReplicaSet.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedReplicaSet.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read status of the specified FederatedReplicaSet
     * @param name name of the FederatedReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedReplicaSetStatus(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedreplicasets/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedReplicaSetStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedReplicaSetStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read the specified FederatedRole
     * @param name name of the FederatedRole
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedRole(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedroles/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedRole.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedRole.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read the specified FederatedRoleBinding
     * @param name name of the FederatedRoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedRoleBinding(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedrolebindings/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedRoleBinding.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedRoleBinding.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read status of the specified FederatedRoleBinding
     * @param name name of the FederatedRoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedRoleBindingStatus(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedrolebindings/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedRoleBindingStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedRoleBindingStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read status of the specified FederatedRole
     * @param name name of the FederatedRole
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedRoleStatus(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedroles/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedRoleStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedRoleStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read the specified FederatedSecret
     * @param name name of the FederatedSecret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedSecret(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedsecrets/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedSecret.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedSecret.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read status of the specified FederatedSecret
     * @param name name of the FederatedSecret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedSecretStatus(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedsecrets/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedSecretStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedSecretStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read the specified FederatedService
     * @param name name of the FederatedService
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedService(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedservices/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedService.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedService.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read the specified FederatedServiceAccount
     * @param name name of the FederatedServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedServiceAccount(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedserviceaccounts/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedServiceAccount.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedServiceAccount.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read status of the specified FederatedServiceAccount
     * @param name name of the FederatedServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedServiceAccountStatus(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedserviceaccounts/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedServiceAccountStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedServiceAccountStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * read status of the specified FederatedService
     * @param name name of the FederatedService
     * @param namespace object name and auth scope, such as for teams and projects
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param resourceVersion When specified: - if unset, then the result is returned from remote storage based on quorum-read flag; - if it\&#39;s 0, then we simply return what we currently have in cache, no guarantee; - if set to non zero, then the result is at least as fresh as given rv.
     */
    public async readNamespacedFederatedServiceStatus(
        name: string,
        namespace: string,
        pretty?: string,
        resourceVersion?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedservices/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling readNamespacedFederatedServiceStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling readNamespacedFederatedServiceStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (resourceVersion !== undefined) {
            localVarQueryParameters['resourceVersion'] = ObjectSerializer.serialize(
                resourceVersion,
                'string',
            );
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'GET',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace the specified FederatedClusterAddon
     * @param name name of the FederatedClusterAddon
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceFederatedClusterAddon(
        name: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusteraddons/{name}'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceFederatedClusterAddon.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceFederatedClusterAddon.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace status of the specified FederatedClusterAddon
     * @param name name of the FederatedClusterAddon
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceFederatedClusterAddonStatus(
        name: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusteraddons/{name}/status'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceFederatedClusterAddonStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceFederatedClusterAddonStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace the specified FederatedClusterRole
     * @param name name of the FederatedClusterRole
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceFederatedClusterRole(
        name: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusterroles/{name}'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceFederatedClusterRole.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceFederatedClusterRole.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace the specified FederatedClusterRoleBinding
     * @param name name of the FederatedClusterRoleBinding
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceFederatedClusterRoleBinding(
        name: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusterrolebindings/{name}'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceFederatedClusterRoleBinding.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceFederatedClusterRoleBinding.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace status of the specified FederatedClusterRoleBinding
     * @param name name of the FederatedClusterRoleBinding
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceFederatedClusterRoleBindingStatus(
        name: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusterrolebindings/{name}/status'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceFederatedClusterRoleBindingStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceFederatedClusterRoleBindingStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace status of the specified FederatedClusterRole
     * @param name name of the FederatedClusterRole
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceFederatedClusterRoleStatus(
        name: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedclusterroles/{name}/status'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceFederatedClusterRoleStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceFederatedClusterRoleStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace the specified FederatedCustomResourceDefinition
     * @param name name of the FederatedCustomResourceDefinition
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceFederatedCustomResourceDefinition(
        name: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedcustomresourcedefinitions/{name}'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceFederatedCustomResourceDefinition.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceFederatedCustomResourceDefinition.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace status of the specified FederatedCustomResourceDefinition
     * @param name name of the FederatedCustomResourceDefinition
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceFederatedCustomResourceDefinitionStatus(
        name: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/federatedcustomresourcedefinitions/{name}/status'.replace(
                '{' + 'name' + '}',
                encodeURIComponent(String(name)),
            );
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceFederatedCustomResourceDefinitionStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceFederatedCustomResourceDefinitionStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace the specified FederatedAddon
     * @param name name of the FederatedAddon
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedAddon(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedaddons/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedAddon.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedAddon.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedAddon.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace status of the specified FederatedAddon
     * @param name name of the FederatedAddon
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedAddonStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedaddons/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedAddonStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedAddonStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedAddonStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace the specified FederatedAddonsDeployment
     * @param name name of the FederatedAddonsDeployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedAddonsDeployment(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedaddonsdeployments/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedAddonsDeployment.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedAddonsDeployment.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedAddonsDeployment.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace status of the specified FederatedAddonsDeployment
     * @param name name of the FederatedAddonsDeployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedAddonsDeploymentStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedaddonsdeployments/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedAddonsDeploymentStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedAddonsDeploymentStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedAddonsDeploymentStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace the specified FederatedConfigMap
     * @param name name of the FederatedConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedConfigMap(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedconfigmaps/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedConfigMap.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedConfigMap.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedConfigMap.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace status of the specified FederatedConfigMap
     * @param name name of the FederatedConfigMap
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedConfigMapStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedconfigmaps/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedConfigMapStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedConfigMapStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedConfigMapStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace the specified FederatedDeployment
     * @param name name of the FederatedDeployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedDeployment(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federateddeployments/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedDeployment.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedDeployment.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedDeployment.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace status of the specified FederatedDeployment
     * @param name name of the FederatedDeployment
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedDeploymentStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federateddeployments/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedDeploymentStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedDeploymentStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedDeploymentStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace the specified FederatedIngress
     * @param name name of the FederatedIngress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedIngress(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedingresses/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedIngress.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedIngress.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedIngress.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace status of the specified FederatedIngress
     * @param name name of the FederatedIngress
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedIngressStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedingresses/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedIngressStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedIngressStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedIngressStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace the specified FederatedJob
     * @param name name of the FederatedJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedJob(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedjobs/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedJob.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedJob.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedJob.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace status of the specified FederatedJob
     * @param name name of the FederatedJob
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedJobStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedjobs/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedJobStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedJobStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedJobStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace the specified FederatedNamespace
     * @param name name of the FederatedNamespace
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedNamespace(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatednamespaces/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedNamespace.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedNamespace.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedNamespace.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace status of the specified FederatedNamespace
     * @param name name of the FederatedNamespace
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedNamespaceStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatednamespaces/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedNamespaceStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedNamespaceStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedNamespaceStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace the specified FederatedReplicaSet
     * @param name name of the FederatedReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedReplicaSet(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedreplicasets/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedReplicaSet.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedReplicaSet.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedReplicaSet.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace status of the specified FederatedReplicaSet
     * @param name name of the FederatedReplicaSet
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedReplicaSetStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedreplicasets/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedReplicaSetStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedReplicaSetStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedReplicaSetStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace the specified FederatedRole
     * @param name name of the FederatedRole
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedRole(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedroles/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedRole.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedRole.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedRole.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace the specified FederatedRoleBinding
     * @param name name of the FederatedRoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedRoleBinding(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedrolebindings/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedRoleBinding.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedRoleBinding.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedRoleBinding.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace status of the specified FederatedRoleBinding
     * @param name name of the FederatedRoleBinding
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedRoleBindingStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedrolebindings/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedRoleBindingStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedRoleBindingStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedRoleBindingStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace status of the specified FederatedRole
     * @param name name of the FederatedRole
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedRoleStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedroles/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedRoleStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedRoleStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedRoleStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace the specified FederatedSecret
     * @param name name of the FederatedSecret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedSecret(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedsecrets/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedSecret.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedSecret.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedSecret.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace status of the specified FederatedSecret
     * @param name name of the FederatedSecret
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedSecretStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedsecrets/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedSecretStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedSecretStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedSecretStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace the specified FederatedService
     * @param name name of the FederatedService
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedService(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedservices/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedService.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedService.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedService.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace the specified FederatedServiceAccount
     * @param name name of the FederatedServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedServiceAccount(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedserviceaccounts/{name}'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedServiceAccount.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedServiceAccount.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedServiceAccount.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace status of the specified FederatedServiceAccount
     * @param name name of the FederatedServiceAccount
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedServiceAccountStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedserviceaccounts/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedServiceAccountStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedServiceAccountStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedServiceAccountStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
    /**
     * replace status of the specified FederatedService
     * @param name name of the FederatedService
     * @param namespace object name and auth scope, such as for teams and projects
     * @param body
     * @param pretty If \&#39;true\&#39;, then the output is pretty printed.
     * @param dryRun When present, indicates that modifications should not be persisted. An invalid or unrecognized dryRun directive will result in an error response and no further processing of the request. Valid values are: - All: all dry run stages will be processed
     * @param fieldManager fieldManager is a name associated with the actor or entity that is making these changes. The value must be less than or 128 characters long, and only contain printable characters, as defined by https://golang.org/pkg/unicode/#IsPrint.
     */
    public async replaceNamespacedFederatedServiceStatus(
        name: string,
        namespace: string,
        body: object,
        pretty?: string,
        dryRun?: string,
        fieldManager?: string,
        options: { headers: { [name: string]: string } } = { headers: {} },
    ): Promise<{ response: http.IncomingMessage; body: object }> {
        const localVarPath =
            this.basePath +
            '/apis/types.kubefed.io/v1beta1/namespaces/{namespace}/federatedservices/{name}/status'
                .replace('{' + 'name' + '}', encodeURIComponent(String(name)))
                .replace('{' + 'namespace' + '}', encodeURIComponent(String(namespace)));
        let localVarQueryParameters: any = {};
        let localVarHeaderParams: any = (<any>Object).assign({}, this.defaultHeaders);
        const produces = ['application/json', 'application/yaml'];
        // give precedence to 'application/json'
        if (produces.indexOf('application/json') >= 0) {
            localVarHeaderParams.Accept = 'application/json';
        } else {
            localVarHeaderParams.Accept = produces.join(',');
        }
        let localVarFormParams: any = {};

        // verify required parameter 'name' is not null or undefined
        if (name === null || name === undefined) {
            throw new Error(
                'Required parameter name was null or undefined when calling replaceNamespacedFederatedServiceStatus.',
            );
        }

        // verify required parameter 'namespace' is not null or undefined
        if (namespace === null || namespace === undefined) {
            throw new Error(
                'Required parameter namespace was null or undefined when calling replaceNamespacedFederatedServiceStatus.',
            );
        }

        // verify required parameter 'body' is not null or undefined
        if (body === null || body === undefined) {
            throw new Error(
                'Required parameter body was null or undefined when calling replaceNamespacedFederatedServiceStatus.',
            );
        }

        if (pretty !== undefined) {
            localVarQueryParameters['pretty'] = ObjectSerializer.serialize(pretty, 'string');
        }

        if (dryRun !== undefined) {
            localVarQueryParameters['dryRun'] = ObjectSerializer.serialize(dryRun, 'string');
        }

        if (fieldManager !== undefined) {
            localVarQueryParameters['fieldManager'] = ObjectSerializer.serialize(fieldManager, 'string');
        }

        (<any>Object).assign(localVarHeaderParams, options.headers);

        let localVarUseFormData = false;

        let localVarRequestOptions: localVarRequest.Options = {
            method: 'PUT',
            qs: localVarQueryParameters,
            headers: localVarHeaderParams,
            uri: localVarPath,
            useQuerystring: this._useQuerystring,
            json: true,
            body: ObjectSerializer.serialize(body, 'object'),
        };

        let authenticationPromise = Promise.resolve();
        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.BearerToken.applyToRequest(localVarRequestOptions),
        );

        authenticationPromise = authenticationPromise.then(() =>
            this.authentications.default.applyToRequest(localVarRequestOptions),
        );
        return authenticationPromise.then(() => {
            if (Object.keys(localVarFormParams).length) {
                if (localVarUseFormData) {
                    (<any>localVarRequestOptions).formData = localVarFormParams;
                } else {
                    localVarRequestOptions.form = localVarFormParams;
                }
            }
            return new Promise<{ response: http.IncomingMessage; body: object }>((resolve, reject) => {
                localVarRequest(localVarRequestOptions, (error, response, body) => {
                    if (error) {
                        reject(error);
                    } else {
                        body = ObjectSerializer.deserialize(body, 'object');
                        if (response.statusCode && response.statusCode >= 200 && response.statusCode <= 299) {
                            resolve({ response: response, body: body });
                        } else {
                            reject(new HttpError(response, body, response.statusCode));
                        }
                    }
                });
            });
        });
    }
}
